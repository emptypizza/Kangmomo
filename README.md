안녕하세요, 오늘 제가 만든 게임을 소개하겠습니다.
오늘 프로젝트명은 '폐지소녀 강모모'로, 폐지를 주워 아이돌이 되는 꿈을 가진 16.9세 소녀의 이야기를 담고 있습니다.
게임의 목표는 제한된 5분의 시간 동안 육각형 그리드에서 랜덤으로 나타나는 폐지를 최대한 많이 줍고, 위험요소를 피해가면서 아이돌을 만나기 위한 조건을 충족하는 것입니다.
이를 위해 Unity 엔진을 활용하여 육각형 형태의 그리드 시스템을 구현하였습니다. 육각형은 게임 내 움직임을 더 재미있고 전략적으로 만들어 주었습니다.
캐릭터는 화면 클릭을 통해 이동시키며, 헥사곤 좌표와 월드 좌표를 변환하는 방식으로 정확한 위치에 이동하도록 구현하였습니다. 플레이어가 특정 헥사곤 셀 위로 이동하면 해당 셀이 활성화되는 간단한 상호작용도 포함했습니다.
코드 구현에서는 게임 관리를 담당하는 GameManager와 사용자 입력을 처리하는 UIcode, 플레이어의 움직임과 충돌 처리를 담당하는 player 스크립트로 구성되었습니다.
오늘 준비된 시연을 통해 게임의 기본적인 동작과 플레이 방식을 확인하실 수 있으며, 앞으로 더욱 다양한 인터랙션과 미니게임 요소를 추가하여 몰입감 있는 게임으로 발전시킬 계획입니다.
감사합니다.

YYTづfjqん여러분 및 초밥어부님 알겠습니다. 프로젝트의 각 스크립트가 어떤 기술을 사용하고 어떻게 상호작용하는지 기술 중심으로 설명해 드리겠습니다.
전체적으로 프로젝트는 싱글톤(Singleton) 패턴을 적극적으로 활용하여 GameManager와 SoundManager 같은 핵심 시스템을 어디서든 쉽게 참조할 수 있도록 설계되었습니다. 핵심 게임 플레이는 사용자의 클릭 입력을 헥사고날 그리드 좌표로 변환하여 처리하는 방식으로 이루어집니다.

1. 핵심 시스템: 헥사고날 그리드와 플레이어 상호작용
이 시스템은 GameManager, player, UIcode 세 스크립트가 유기적으로 연동하여 동작합니다.
GameManager.cs
싱글톤 패턴: Instance 프로퍼티를 통해 게임 내 어디서든 GameManager.Instance로 접근할 수 있는 중앙 관리자 역할을 합니다1.
프로시저럴 그리드 생성: GenerateGrid 메서드에서 중첩 for문을 사용해 gridWidth와 gridHeight에 따라 동적으로 육각형 타일들을 생성합니다2.
헥사곤 좌표계산: Flat-Top 방식의 육각형 타일을 배치하기 위해 x좌표는 cellWidth * 0.75f 간격으로, y좌표는 홀수 열일 때 반 칸(0.5f)의 오프셋을 주어 엇갈리게 배치하는 수학적 계산을 사용합니다3. 또한 그리드가 화면 중앙에 오도록 전체 크기를 계산해 오프셋을 적용합니다4.
유효성 검사: IsCellExists 함수를 통해 특정 좌표가 생성된 그리드 범위 내에 있는지 확인하여, 플레이어가 맵 밖으로 이동하는 것을 방지하는 로직을 제공합니다5.
player.cs
좌표 변환: 이 스크립트의 핵심 기술입니다.
HexToWorld: GameManager가 타일을 배치한 방식의 역산(逆算)을 통해, (q, r) 형태의 정수 그리드 좌표를 실제 게임 월드의 (x, y) 좌표로 변환합니다6.
WorldToHex: Mathf.RoundToInt를 사용하여 월드 좌표를 가장 가까운 헥사 그리드 좌표로 변환(스냅)합니다7. 이 두 함수가 정확히 역연산 관계에 있어야 시스템이 정상 동작합니다.
코루틴(Coroutine) 기반 이동: MoveRoutine 코루틴을 사용하여 플레이어 이동을 비동기적으로 처리합니다8.
while 루프와 Vector3.MoveTowards를 사용해 현재 위치에서 목표 지점까지 프레임마다 조금씩 부드럽게 이동시킵니다9.
상태 잠금 (State Lock): isMoving이라는 boolean 플래그를 두어, 이동이 시작되면 true로 설정하고 끝나면 false로 변경합니다10. 이를 통해 플레이어가 이동하는 도중에 다른 이동 명령이 중첩되어 발생하는 오류를 방지합니다.
UIcode.cs
입력 처리 및 시스템 연동: 사용자 입력을 받아 핵심 시스템들을 연결하는 '교량' 역할을 합니다.
스크린-월드 좌표 변환: Input.GetMouseButtonDown(0)로 클릭을 감지한 후, Camera.main.ScreenToWorldPoint를 사용해 2D 화면상의 클릭 위치를 게임 월드 좌표로 변환합니다11.
로직 호출: 변환된 월드 좌표를 player.WorldToHex에 넘겨 그리드 좌표를 얻고, 이 좌표를 다시 GameManager.Instance.IsCellExists로 검증한 뒤, 최종적으로 player.MoveToWorldPosition을 호출해 이동 명령을 내립니다12.

2. 콘텐츠 및 게임 로직
ItemSpawner.cs
시간 기반 스폰: Time.time과 nextSpawnTime을 비교하여 spawnRate에 설정된 주기에 따라 아이템/적을 생성하는 타이머 로직을 사용합니다13.
랜덤 위치 지정: Spawn_HorizontalLeft, Spawn_VerticalTop 등의 변수로 스폰 영역을 정의하고, Random.Range를 활용해 해당 범위 내에서 랜덤한 위치에 오브젝트를 생성합니다14.
pc2AI.cs
간단한 확률 기반 AI: InvokeRepeating을 사용해 turnInterval마다 ChooseAction 메서드를 주기적으로 호출하는 턴제 행동 로직을 구현했습니다15.
Random.Range(0f, 1f)로 0과 1 사이의 난수를 생성하여, 0.7 미만일 경우와 아닐 경우로 나누어 AI가 확률에 따라 다른 행동을 하도록 설계되었습니다16.

3. 관리 및 유틸리티 시스템
SoundManager.cs
싱글톤 오디오 관리자: GameManager와 마찬가지로 싱글톤 패턴을 사용해 사운드 재생을 중앙에서 관리합니다17.
Dictionary를 활용한 사운드 관리: SoundType 열거형(Enum)을 키(Key)로, AudioClip을 값(Value)으로 가지는 Dictionary를 사용합니다18. 이를 통해 "Click"이나 "Fire" 같은 사운드 타입을 지정하는 것만으로 쉽게 원하는 오디오 클립을 찾아 재생할 수 있습니다.
다중 AudioSource 활용: speaker_A, speaker_B 등 여러 개의 AudioSource 컴포넌트를 두어, 동시에 여러 효과음이 재생될 때 서로 끊기지 않도록 처리합니다19.
LogoManager.cs
코루틴 기반 씬 전환: FadeInAndOut 코루틴을 사용해 로고 이미지를 서서히 나타나게 하고(Fade-in) 사라지게(Fade-out) 한 후, SceneManager.LoadScene으로 다음 씬을 로드합니다20.
알파 값 조작: UI 이미지의 color.a (알파 값)를 for 루프 안에서 Time.deltaTime을 이용해 점진적으로 변경함으로써 부드러운 페이드 효과를 구현합니다21.

4. 기타 및 비활성 스크립트
Movement2D.cs: Vector3.Lerp를 사용하는 또 다른 이동 스크립트이지만, 현재 player.cs가 Vector3.MoveTowards 기반의 이동 로직을 이미 구현하고 있으므로, 이 스크립트는 이전 버전이거나 현재 사용되지 않는 코드로 보입니다22.
Item.cs: 현재는 내용이 거의 비어있지만, 주석 처리된 코드를 보면 아이템과 플레이어 간의 충돌을 감지(OnTriggerEnter2D)하고 점수나 체력을 변경하는 로직을 담기 위한 템플릿 스크립트입니다23.
Maincamera.cs: 내용이 비어있는 기본 스크립트입니다24.
